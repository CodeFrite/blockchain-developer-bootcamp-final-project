// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

/* EXTERNAL DEPENDENCIES */
//import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol";

/* INTERNAL DEPENDENCIES */
import "./CommonStructs.sol";
import "./Clauses.sol";
import "./Deals.sol";
import "./Interpreter.sol";

// TODO : Ajouter un payable fallback a tous les contracts pour voir ce qu'on fait quand on reçoit de l'argent par erreur
//        ==> Hériter d'une classe qui redirige l'argent vers le proxy ou bien juste rembourser les sous


/// @title Medium: Entry point exposing the public interface to the end users
/// @notice lets-make-a-deal.eth allows you to make an agreement between different parties and automatically route ETH to different addresses based on simple rules.
/// @dev Medium: Entry
contract Proxy { //is Ownable {
    
    /* STORAGE VARIABLES */
    uint private totalValueLockedInDeals;
    uint private transactionMinimalValue;
    
    // Internal contracts addresses
    Clauses private clausesContract;
    Deals private dealsContract;
    Interpreter private interpreterContract;
    
    // Fees
    uint public contractCreationFees; // Contract creation price in ETH
    uint public transactionFees;      // Fees on calls to makePayment() in % of msg.value (auto calculated in front (= msg.value*(1+fees/100))
    
    /* MAPPINGS */
    
    /* MODIFIERS */
    
    /* EVENTS */
    /// @notice The Deals contract address has been changed 
    /// @dev Fired on call to setDealsContractAddress()
    /// @param _from : msg.sender
    /// @param _old : old address of the smart contract Deals
    /// @param _new : new address of the smart contract Deals
    event ModifyDealsContractAddress(address _from, address _old, address _new);
    
    /// @notice The Clauses contract address has been changed 
    /// @dev Fired on call to setClausesContractAddress()
    /// @param _from : msg.sender
    /// @param _old : old address of the smart contract Rules
    /// @param _new : new address of the smart contract Rules
    event ModifyClausesContractAddress(address _from, address _old, address _new);
 
    /// @notice The Clauses contract address has been changed 
    /// @dev Fired on call to setClausesContractAddress()
    /// @param _from : msg.sender
    /// @param _old : old address of the smart contract Rules
    /// @param _new : new address of the smart contract Rules
    event ModifyInterpreterContractAddress(address _from, address _old, address _new);
    
    /// @notice The transaction minimal value
    /// @dev Fired on call to setTransactionMinimalValue()
    /// @param _from : msg.sender
    /// @param _old : old value of transaction minimal value
    /// @param _new : new value of transaction minimal value
    event ModifyTransactionMinimalValue(address _from, uint _old, uint _new);
 
    event ModifyContractCreationFees(address _from, uint _old, uint _new);
    event ModifyTransactionFees(address _from, uint _old, uint _new);
    event PayTransactionFees(address _from, uint _fees);
        
    /* CONSTRUCTOR */
    /// @dev Constructor: Initialize storage variables
    constructor () {
        totalValueLockedInDeals = 0;
        transactionMinimalValue = 0;
    }
    
    /* SEND & FALLBACK */
    // TODO: https://docs.soliditylang.org/en/v0.8.9/contracts.html#receive-ether-function
    // If I do not include a payable send or fallback, the contract will return any ETH send to the contract with a call without call values (ok for me i think)
    
    /* GETTERS & SETTERS */
    
    /// @dev Get the total value locked in all deals
    /// @return private member totalValueLockedInDeals
    function getTotalValueLockedInDeals() public view returns (uint) {
        return totalValueLockedInDeals;
    }
    
    /// @dev Get the transaction minimal value
    /// @return private member transactionMinimalValue
    function getTransactionMinimalValue() public view returns (uint) {
        return transactionMinimalValue;
    }
    
    /// @dev Set the transaction minimal value
    /// @param _new : new value of the transaction minimal value
    function setTransactionMinimalValue(uint _new) public {
        uint _old = transactionMinimalValue;
        transactionMinimalValue = _new;
        emit ModifyTransactionMinimalValue(msg.sender, _old, _new);
    }
    
    /// @dev Set the address of the smart contract Clauses
    /// @param _new : new address of the smart contract Clauses
    function setClausesContract(address _new) public {
        address _old = address(clausesContract);
        clausesContract = Clauses(_new);
        emit ModifyClausesContractAddress(msg.sender, _old, _new);
    }
    
    /// @dev Set the address of the smart contract Deals
    /// @param _new : new address of the smart contract Deals
    function setDealsContract(address _new) public {
        address _old = address(dealsContract);
        dealsContract = Deals(_new);
        emit ModifyDealsContractAddress(msg.sender, _old, _new);
    }
    
    /// @dev Set the address of the smart contract Interpreter
    /// @param _new : new address of the smart contract Interpreter
    function setInterpreterContract(address _new) public {
        address _old = address(interpreterContract);
        interpreterContract = Interpreter(_new);
        emit ModifyInterpreterContractAddress(msg.sender, _old, _new);
    }
    
    // TODO: Mettre une note sur Github pour expliquer pourquoi je copie oldValue au lieu de direct emit. On emit seulement si on est sur que toute la fonction a runné ok
    function modifyContractCreationFees(uint _newValue) public {
        uint _oldValue = contractCreationFees;
        contractCreationFees = _newValue;
        emit ModifyContractCreationFees(msg.sender, _oldValue, _newValue);
    }
   
    function modifyTransactionFees(uint _newValue) public {
        uint _oldValue = transactionFees;
        transactionFees = _newValue;
        emit ModifyTransactionFees(msg.sender, _oldValue, _newValue);
    }
    
    /** 
     * @dev Create a new deal
     */
    function createDeal(address[] memory _authorizedAccounts, CommonStructs.Node[] memory _astTree) public returns (uint) {
        return dealsContract.createDeal(_authorizedAccounts, _astTree);
    }
    
    function getDeal(uint _dealID) public view returns(address[] memory _authorizedAccounts, CommonStructs.Node[] memory _astTree) {
        return (dealsContract.getAuthorizedAccounts(_dealID), dealsContract.getDeal(_dealID));
    }
    
    function executeDeal(uint _dealID) public returns (CommonStructs.Node memory) {
        return interpreterContract.executeDeal(_dealID);
    }
    
    function _payFees(uint _fees) public payable {
        payable(address(this)).transfer(_fees);
        emit PayTransactionFees(msg.sender, _fees);
    }
}
